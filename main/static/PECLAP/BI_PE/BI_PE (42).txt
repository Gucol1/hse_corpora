Introduction
Background. The amount of information produced and consumed is constantly growing, and so text analysis becomes more and more useful. However, no human can analyze all this data single-handedly. Nowadays computers are heavily involved in text analysis. Computational power does not, however, increase proportionally to information - there still is no component that can make a machine "understand" a text as a human would. That is the reason linguists and programmers collaborated and devised the following steps of text analysis: Markup, Normalization and Analysis.
A combination of these steps is called a linguistic analysis pipeline. Such pipeline is a core part of any linguistic analysis system. A system like this can be used by students, who want to get an insight into how they can improve their work, or by teachers checking students work for mistakes.
The system consists of several extensions that have to communicate in order to fulfill its purpose - linguistic analysis. The extensions roughly correspond with the steps in the pipeline and most often are represented by classes for ease of replacement. These extensions can be written in different languages.
Problem Statement. As of now there is no universally accepted way to integrate all programming languages. This poses a problem, as integrating multiple languages is one of the reqerements.
The extensions must exchange detailed information and perform different operations in different languages. For that reason, a subsystem should be developed, one that integrates those languages together. 
Aim and Objectives. The goal of this work is to develop an extension subsystem that can expand the capabilities main system with different languages.
To achieve this goal it is necessary to carry out the following tasks:
1. Carry out the analysis of a subject area.
1.1. Carry out the analysis of technologies of systems integration in different languages.
1.2. Patters of integration
1.3. Select the best methodology/concept for integration
2. Carry out system design
3. Implement the plugin system
The new system will be useful for HSE teachers as the main audience, as well as for students, as students will be able to get feedback on their work quicker, maybe even without the participation of any teachers. The subsystem is aimed at programmers in hopes that they develop extensions and submodules for the completed system.
Delimitations of the Study. In this Project Proposal there will be a review of integration methods, a comparison of these methods, choice and implementation of the most relevant of them and a description of the work process.
The subsystem should be focused on integrating three languages - Java, Python and C#. Methods used for integration do not have to be universal for all existing languages. Addition of new languages should not be impossible.
Literature Review
In this literature review I'm compiling a list of possible solutions to the problem of programming language integration. One of these solutions will be chosen in this section as the most suitable and the most likely to be implemented.
Different parts of the system can be implemented in various programming languages. Some of them are geared more towards a specific task which means every step of the linguistic analysis pipeline can be written in its own language. The main problem with that approach is a lack of a system-wide means of programming language integration. There is another approach that can help achieve integration: networking protocols, and inter-process communication. That approach, though, is meant for information interchange more than for any kind of integration.
Integration is quite widespread, although not in any way that would help. Different dialects of SQL are callable from all major languages. There are also virtual machines that act as language integration platforms: Java Virtual Machine (JVM) which enables the interoperability of Java, Scala and Kotlin, as well as Microsoft's Common Language Runtime (CLR) which, in turn, does the same for C#, Visual Basic and F#. Java and Kotlin are interoperable, C# and Visual Basic are interoperable as well. Java and C#, however, are not even close to interoperability, even though they are very similar - despite the very similar syntax and object model. 
Program code is a text-based, human-readable version of what a processor is doing - machine code. That means that somewhere between writing the code and running the program something translates program code into machine code. That, surprisingly enough, is a program as well. If one were to write such a program with integration in mind it could be possible to unify all the languages. This approach is called re-implementation.
Re-implementation as a means of integration is not impossible, it usually is not practical, because a good language should be well maintained, and it is almost never done successfully by just one person - even teams are prone to failure. Projects like IronPython that enables Python to run in in CLR and Jython that enables Python to run on JVM only serve as proof - both teams implement Python 2.7 - a version that is meant to be deprecated in April 2020. Reimplementing languages to force them to run on a custom virtual machine was proven to be successful by Matthias Grimmer, and it is possible to add more as needed. But it is a gigantic mountain of work upfront, and one that requires quite a lot of maintenance as languages are updated and new features get added.
Python is a programming language that is very well integrated with C. The most used Python interpreter is called CPython and is written in C, just like many efficient Python libraries. For example: numpy, a popular library for advanced linear algebraic operations (and much more) is partially written in C because it is a more performant language than Python.
It is not impossible to call C/C++ from Java via a Java Native Interface, but it is not as easy to achieve the reverse. Even if it was easy, the next step would be rewriting a sizable part of the code in C++, which is not productive and would defeat the purpose of integration. And, to top it all off, the technology is so old the documentation for them is not on the official website and can only be found on the web archive.
One other possible course of action is using web technologies as a way to send data from one language to another - this form of integration has been in use for decades and is called a web API. Almost all interactions with the web require an additional step - conversion from how a language "sees" the data that a program produces - a native object to JSON - JavaScript Object Notation. This notation is quite widespread, and most languages have a way to convert a so-called "JSON blob" to a dictionary or to a native object. This is usually a computationally costly operation, which is a great reason to make whatever it is that needs to be done worth the overhead of converting an object into JSON before sending it over, converting it from JSON to another native object upon arrival, and doing all this once more after an operation is completed to send the response back.
Conversions are not the only thing that happens, though. A method is not going to call itself. A translation from data to a method call needs to occur. The size of the overhead only increases because all languages in question will be running a web server that is waiting for a request. This is more straightforward to implement than for example, passing a JSON blob as a command line argument, as well as (if properly set up) having an advantage of being accessible over the network, making it a kind of a microservice.
Another way to achieve integration would be writing some data to a file from one programming language, reading that file from another language, and performing some action based upon the information written to that file. That kind of solution would require a polling-based system, or a file system notification about a change to the file. While that, compared to a web server, is a lot less overhead, this approach would still require a lot of data conversion, and a universally understood format. In that case JSON is still a very reasonable choice, as the alternative, XML, is much more verbose, but not actually that much easier to parse. Evaluation criteria for integration methods are presented in the table 1.
The results of comparing integration methods show that the microservice architecture is the best choice, since it meets most of the necessary criteria. In the next part of work, the Methods section, the algorithm of the development process will be described.
Methods
The goal of this work can be achieved by using methods listed and described in the following paragraphs. 
The first step is identifying the problem space. While it is most likely that Python, Java and C# are the ones that are going to be integrated, it is not impossible to change the list of the required languages. The languages are only a part of the problem space. The system is one that is built for linguistic analysis, and a part of this work is defining classes suitable for a linguistic analysis pipeline. Their suitability is determined by how easy it is to adapt a class for a specific purpose, as linguistic analysis can be done in a variety of different ways. 
The second step is the description and selection of the best tool for the job that is integration. The descriptions of most possible tools are mentioned in the literature review. This time around the desired outcome is a more in-depth explanation of the method of choice. The one that makes the most sense is the one that results in a microservice - it is simple and practical. 
The third step is all about compiling the requirements and documenting them. This is useful as a verification tool, used to check if the finished system meets the expectations placed on it, as well as to design the system in a way that would fit the requirements.
The penultimate step is designing the system - in this case algorithms for interaction with the web and making sure the correct function is called upon the delivery of a message. This subsystem does not have a user interface - so a real one is not going to be designed, however, for the purposes of demonstration a mock program is going to be written to show the capabilities of the system.
The last step is the implementation. It will be carried out according to the plan devised in the previous step. Testing and debugging are a vital part of the development cycle, as the combination of the two always improves the quality of a system in a major way. Python version will make use of the Flask framework, Java version will be implemented with Spring Boot, and C# will be using .NET Framework.
Anticipated Results
The main anticipated result of the work is a working extension subsystem that can be used in a similar way across multiple languages. More specifically, with Python, Java and C# are the languages that are going to be the focus, with the ability to add more. Languages will communicate using web technologies, which means communicating over the network should be as easy as changing a setting. 
As well as the extension subsystem, another part of the result is a set of components that are useful as steps within a linguistic analysis pipeline. Those also have to be in every one of the languages mentioned above. That way the components integrated into the resulting system can be expected to behave the same across the board. 
Conclusion
As a result of this work an extension subsystem of a linguistic research system will be developed. The subsystem may help other programmers in implementing the complete system and adding new components to it, as with the help of this work the system became language independent. The other important point is that the system can work in a distributed manner, as web servers can be placed on different machines. It is mostly targeted at programmers that can develop extensions and submodules for the completed system.
